#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

SCREEN_PASS_TEXTURE_VIEWPORT(ViewParams)

SamplerState InputSampler;
Texture2D SceneColor;
Texture2D SceneDepth;
Texture2D Noise;
Texture2D FogNoise;
float4 LineColor;
float4 FogColor;
float4 FogSmokeColor;
float EdgeThickness;
float EdgeIntensity;
float DepthBias;
float SceneDepthSize;
float NoiseSize;
float NoiseStrength;
float Time;
float MovementSpeed;
float FogMovementSpeed;
float FogDensity;
float FogNoiseScale;
float FogFar;
uint DebugLines;

float2 PosToUV(float2 Pos);
float Edge(float2 uv);
float2 GetMovementDirection(float2 uv);
float3 GetFog(float2 uv, float3 sceneColor);

float4 AuraMainPS(float4 SvPosition : SV_POSITION) : SV_Target0
{
    float2 ScreenUV = PosToUV(SvPosition).xy;
    float edge = saturate(Edge(ScreenUV));
    float4 sceneColor = SceneColor.SampleLevel(InputSampler, ScreenUV, 0);
    float2 noiseMovementVelocity = GetMovementDirection(ScreenUV) * MovementSpeed * Time;
    float noise = Noise.SampleLevel(InputSampler, ScreenUV * NoiseSize + noiseMovementVelocity, 0).r;
    float3 fog = GetFog(ScreenUV, sceneColor.rgb);
    
    if(DebugLines)
       return edge >= DepthBias ? edge * LineColor : float4(0.f, 0.f, 0.f, 1.f);
    
    float3 edgeColor = LineColor.rgb * noise * NoiseStrength * edge;
    return edge >= DepthBias ? float4(edgeColor + fog, 1.f) : float4(fog, 1.f);
    //return float4(fog, 1.f);
}

float3 GetFog(float2 uv, float3 sceneColor)
{
    float sceneDepth = SceneDepth.Sample(InputSampler, uv);
    float depthFog = smoothstep(0.f, FogFar, sceneDepth);
    float finalFogIntensity = saturate(1 - depthFog * FogDensity);
    
    float2 fogUV = uv * FogNoiseScale + float2(0.f, FogMovementSpeed) * Time;
    float3 noise = FogNoise.Sample(InputSampler, fogUV);
    
    float3 fogRes = FogColor.rgb + noise * FogSmokeColor.rgb;
    float3 finalColor = lerp(sceneColor, fogRes, finalFogIntensity);
    return finalColor;
}


float2 PosToUV(float2 Pos)
{
    float2 ViewportUV = ((Pos - ViewParams_ViewportMin.xy) * ViewParams_ViewportSizeInverse.xy);
    return ViewportUV * ViewParams_UVViewportSize + ViewParams_UVViewportMin;
}

float2 GetMovementDirection(float2 uv)
{
    float2 result = float2(-1.f, -1.f);
    if (uv.x < 0.5f)
        result.x *= -1;
    if (uv.y < 0.5f)
        result.y *= -1;

    return result;
}

float Edge(float2 uv)
{
    float2 pixelSize = EdgeThickness / ViewParams_ViewportSize;
    float2 sobelMatrix[9] =
    {
        float2(-1, -0.5f), float2(0, -1), float2(1, -0.5f),
        float2(-1, 0), float2(0, 0), float2(1, 0),
        float2(-1, 0.5f), float2(0, 1), float2(1, 0.5f)
    };
        
    float2 gradients = float2(0.f, 0.f);

    for (int i = 0; i < 9; i++)
    {
        int row = i / 3;
        int col = i % 3;

        float offsetX = (col - 1) * pixelSize.x;
        float offsetY = (row - 1) * pixelSize.y;

        float2 offsetUV = float2(uv.x + offsetX, uv.y + offsetY);
           
        float depth = SceneDepth.SampleLevel(InputSampler, offsetUV, 0);
        gradients += sobelMatrix[i] * depth;
    }

    gradients *= EdgeIntensity;

    return length(gradients);
}
